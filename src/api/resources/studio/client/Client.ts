// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../BaseClient";
import * as core from "../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers";
import * as environments from "../../../../environments";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError";
import * as errors from "../../../../errors/index";
import * as serializers from "../../../../serialization/index";
import * as ElevenLabs from "../../../index";
import { ProjectsClient } from "../resources/projects/client/Client";

export declare namespace StudioClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class StudioClient {
    protected readonly _options: NormalizedClientOptions<StudioClient.Options>;
    protected _projects: ProjectsClient | undefined;

    constructor(options: StudioClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    public get projects(): ProjectsClient {
        return (this._projects ??= new ProjectsClient(this._options));
    }

    /**
     * Create and auto-convert a podcast project. Currently, the LLM cost is covered by us but you will still be charged for the audio generation. In the future, you will be charged for both the LLM and audio generation costs.
     *
     * @param {ElevenLabs.BodyCreatePodcastV1StudioPodcastsPost} request
     * @param {StudioClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ElevenLabs.UnprocessableEntityError}
     *
     * @example
     *     await client.studio.createPodcast({
     *         safetyIdentifier: "safety-identifier",
     *         modelId: "eleven_multilingual_v2",
     *         mode: {
     *             type: "conversation",
     *             conversation: {
     *                 hostVoiceId: "aw1NgEzBg83R7vgmiJt6",
     *                 guestVoiceId: "aw1NgEzBg83R7vgmiJt7"
     *             }
     *         },
     *         source: {
     *             type: "text",
     *             text: "This is a test podcast."
     *         }
     *     })
     */
    public createPodcast(
        request: ElevenLabs.BodyCreatePodcastV1StudioPodcastsPost,
        requestOptions?: StudioClient.RequestOptions,
    ): core.HttpResponsePromise<ElevenLabs.PodcastProjectResponseModel> {
        return core.HttpResponsePromise.fromPromise(this.__createPodcast(request, requestOptions));
    }

    private async __createPodcast(
        request: ElevenLabs.BodyCreatePodcastV1StudioPodcastsPost,
        requestOptions?: StudioClient.RequestOptions,
    ): Promise<core.WithRawResponse<ElevenLabs.PodcastProjectResponseModel>> {
        const { safetyIdentifier, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "safety-identifier": safetyIdentifier != null ? safetyIdentifier : undefined,
                "xi-api-key": requestOptions?.apiKey ?? this._options?.apiKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ElevenLabsEnvironment.Production,
                "v1/studio/podcasts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.BodyCreatePodcastV1StudioPodcastsPost.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 240) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PodcastProjectResponseModel.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new ElevenLabs.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ElevenLabsError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/studio/podcasts");
    }
}
