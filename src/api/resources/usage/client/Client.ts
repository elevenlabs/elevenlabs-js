// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../BaseClient";
import * as core from "../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers";
import * as environments from "../../../../environments";
import * as errors from "../../../../errors/index";
import * as serializers from "../../../../serialization/index";
import * as ElevenLabs from "../../../index";

export declare namespace UsageClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class UsageClient {
    protected readonly _options: NormalizedClientOptions<UsageClient.Options>;

    constructor(options: UsageClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    /**
     * Returns the usage metrics for the current user or the entire workspace they are part of. The response provides a time axis based on the specified aggregation interval (default: day), with usage values for each interval along that axis. Usage is broken down by the selected breakdown type. For example, breakdown type "voice" will return the usage of each voice for each interval along the time axis.
     *
     * @param {ElevenLabs.UsageGetRequest} request
     * @param {UsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ElevenLabs.UnprocessableEntityError}
     *
     * @example
     *     await client.usage.get({
     *         startUnix: 1,
     *         endUnix: 1,
     *         includeWorkspaceMetrics: true,
     *         breakdownType: "none",
     *         aggregationInterval: "hour",
     *         aggregationBucketSize: 1,
     *         metric: "credits"
     *     })
     */
    public get(
        request: ElevenLabs.UsageGetRequest,
        requestOptions?: UsageClient.RequestOptions,
    ): core.HttpResponsePromise<ElevenLabs.UsageCharactersResponseModel> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: ElevenLabs.UsageGetRequest,
        requestOptions?: UsageClient.RequestOptions,
    ): Promise<core.WithRawResponse<ElevenLabs.UsageCharactersResponseModel>> {
        const {
            startUnix,
            endUnix,
            includeWorkspaceMetrics,
            breakdownType,
            aggregationInterval,
            aggregationBucketSize,
            metric,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.start_unix = startUnix.toString();
        _queryParams.end_unix = endUnix.toString();
        if (includeWorkspaceMetrics != null) {
            _queryParams.include_workspace_metrics = includeWorkspaceMetrics.toString();
        }

        if (breakdownType != null) {
            _queryParams.breakdown_type = serializers.BreakdownTypes.jsonOrThrow(breakdownType, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (aggregationInterval != null) {
            _queryParams.aggregation_interval = serializers.UsageAggregationInterval.jsonOrThrow(aggregationInterval, {
                unrecognizedObjectKeys: "strip",
            });
        }

        if (aggregationBucketSize != null) {
            _queryParams.aggregation_bucket_size = aggregationBucketSize.toString();
        }

        if (metric != null) {
            _queryParams.metric = serializers.MetricType.jsonOrThrow(metric, { unrecognizedObjectKeys: "strip" });
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "xi-api-key": requestOptions?.apiKey ?? this._options?.apiKey }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ElevenLabsEnvironment.Production,
                "v1/usage/character-stats",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 240) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.UsageCharactersResponseModel.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new ElevenLabs.UnprocessableEntityError(
                        serializers.HttpValidationError.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ElevenLabsError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ElevenLabsError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "body-is-null":
                throw new errors.ElevenLabsError({
                    statusCode: _response.error.statusCode,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ElevenLabsTimeoutError("Timeout exceeded when calling GET /v1/usage/character-stats.");
            case "unknown":
                throw new errors.ElevenLabsError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
